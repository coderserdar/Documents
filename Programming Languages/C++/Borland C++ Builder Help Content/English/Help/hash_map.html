<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>hash_map&lt;Key, Data, HashFcn, EqualKey, Alloc&gt;</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>hash_map&lt;Key, Data, HashFcn, EqualKey, Alloc&gt;</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "containers.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "type.gif" Alt=""   WIDTH = "194"  HEIGHT = "39" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
<tt>Hash_map</tt> is a
<A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
that associates objects of type <tt>Key</tt> with
objects of type <tt>Data</tt>.  <tt>Hash_map</tt> is a 
<A href="PairAssociativeContainer.html">Pair Associative Container</A>,
meaning that its value type is
<tt><A href="pair.html">pair</A>&lt;const Key, Data&gt;</tt>.  It is also a 
<A href="UniqueAssociativeContainer.html">Unique Associative Container</A>,
meaning that no two elements have keys that compare
equal using <tt>EqualKey</tt>.
<P>
Looking up an element in a <tt>hash_map</tt> by its key is efficient,
so <tt>hash_map</tt> is useful for &quot;dictionaries&quot; where the
order of elements is irrelevant.  If it is important for the elements
to be in a particular order, however, then
<tt><A href="Map.html">map</A></tt> is more appropriate.
<h3>Example</h3>
<pre>
struct eqstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) == 0;
  }
};

int main()
{
  hash_map&lt;const char*, int, hash&lt;const char*&gt;, eqstr&gt; months;
  
  months[&quot;january&quot;] = 31;
  months[&quot;february&quot;] = 28;
  months[&quot;march&quot;] = 31;
  months[&quot;april&quot;] = 30;
  months[&quot;may&quot;] = 31;
  months[&quot;june&quot;] = 30;
  months[&quot;july&quot;] = 31;
  months[&quot;august&quot;] = 31;
  months[&quot;september&quot;] = 30;
  months[&quot;october&quot;] = 31;
  months[&quot;november&quot;] = 30;
  months[&quot;december&quot;] = 31;
  
  cout &lt;&lt; &quot;september -&gt; &quot; &lt;&lt; months[&quot;september&quot;] &lt;&lt; endl;
  cout &lt;&lt; &quot;april     -&gt; &quot; &lt;&lt; months[&quot;april&quot;] &lt;&lt; endl;
  cout &lt;&lt; &quot;june      -&gt; &quot; &lt;&lt; months[&quot;june&quot;] &lt;&lt; endl;
  cout &lt;&lt; &quot;november  -&gt; &quot; &lt;&lt; months[&quot;november&quot;] &lt;&lt; endl;
}
</pre>
<h3>Definition</h3>
Defined in the header <A href="hash_map">hash_map</A>, and in the backward-compatibility
header <A href="hash_map.h">hash_map.h</A>.  This class is an SGI extension; it is not part
of the C++ standard.
<h3>Template parameters</h3>
<Table border>
<TR>
<TH>
Parameter
</TH>
<TH>
Description
</TH>
<TH>
Default
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>Key</tt>
</TD>
<TD VAlign=top>
The hash_map's key type.  This is also defined as <tt>hash_map::key_type</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>Data</tt>
</TD>
<TD VAlign=top>
The hash_map's data type.  This is also defined as <tt>hash_map::data_type</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>HashFcn</tt>
</TD>
<TD VAlign=top>
The <A href="HashFunction.html">hash function</A> used by the hash_map.  This is also defined
   as <tt>hash_map::hasher</tt>.  
</TD>
<TD VAlign=top>
<tt><A href="hash.html">hash</A>&lt;Key&gt;</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>EqualKey</tt>
</TD>
<TD VAlign=top>
The hash_map key equality function: a <A href="BinaryPredicate.html">binary predicate</A> that
   determines whether two keys are equal.  This is also defined as
   <tt>hash_map::key_equal</tt>.
</TD>
<TD VAlign=top>
<tt><A href="equal_to.html">equal_to</A>&lt;Key&gt;</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>Alloc</tt>
</TD>
<TD VAlign=top>
The <tt>hash_map</tt>'s allocator, used for all internal memory management.
</TD>
<TD VAlign=top>
<tt><A href="Allocators.html">alloc</A></tt>
</TD>
</tr>
</table>
<h3>Model of</h3>
<A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>,
<A href="PairAssociativeContainer.html">Pair Associative Container</A>
<h3>Type requirements</h3>
<UL>
<LI>
<tt>Key</tt> is <A href="Assignable.html">Assignable</A>.
<LI>
<tt>EqualKey</tt> is a <A href="BinaryPredicate.html">Binary Predicate</A> whose argument type
   is <tt>Key</tt>.
<LI>
<tt>EqualKey</tt> is an equivalence relation.
<LI>
<tt>Alloc</tt> is an <A href="Allocators.html">Allocator</A>.
</UL>
<h3>Public base classes</h3>
None.
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>key_type</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
The <tt>hash_map</tt>'s key type, <tt>Key</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>data_type</tt>
</TD>
<TD VAlign=top>
 <A href="PairAssociativeContainer.html">Pair Associative Container</A>
</TD>
<TD VAlign=top>
The type of object associated with the keys.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type</tt>
</TD>
<TD VAlign=top>
 <A href="PairAssociativeContainer.html">Pair Associative Container</A>
</TD>
<TD VAlign=top>
The type of object, <tt>pair&lt;const key_type, data_type&gt;</tt>, stored in the hash_map.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hasher</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
The <tt>hash_map</tt>'s <A href="HashFunction.html">hash function</A>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>key_equal</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
 <A href="functors.html">Function object</A> that compares keys for equality.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>pointer</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Pointer to <tt>T</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reference</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Reference to <tt>T</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reference</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const reference to <tt>T</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
An unsigned integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>difference_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
A signed integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate through a <tt>hash_map</tt>. <A href="#1">[1]</A>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate through a <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator begin()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the beginning of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator end()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the end of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator begin() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>const_iterator</tt> pointing to the beginning of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator end() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>const_iterator</tt> pointing to the end of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type size() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the size of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type max_size() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the largest possible size of the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool empty() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
<tt>true</tt> if the <tt>hash_map</tt>'s size is <tt>0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type bucket_count() const</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Returns the number of buckets used by the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void resize(size_type n)</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Increases the bucket count to at least <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hasher hash_funct() const</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>hasher</tt> object used by the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>key_equal key_eq() const</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>key_equal</tt> object used by the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hash_map()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hash_map(size_type n)</tt>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>hash_map</tt> with at least <tt>n</tt> buckets.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
hash_map(size_type n, 
         const hasher&amp; h)
</pre>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>hash_map</tt> with at least <tt>n</tt> buckets, using <tt>h</tt>
   as the hash function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
hash_map(size_type n,
         const hasher&amp; h, 
         const key_equal&amp; k)
</pre>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>hash_map</tt> with at least <tt>n</tt> buckets, using <tt>h</tt>
   as the hash function and <tt>k</tt> as the key equal function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
hash_map(InputIterator f, InputIterator l)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates a hash_map with a copy of a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
hash_map(InputIterator f, InputIterator l,
         size_type n)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates a hash_map with a copy of a range and a bucket count of at
   least <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
hash_map(InputIterator f, InputIterator l,
         size_type n, const hasher&amp; h)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates a hash_map with a copy of a range and a bucket count of at
   least <tt>n</tt>, using <tt>h</tt> as the hash function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
hash_map(InputIterator f, InputIterator l,
         size_type n, const hasher&amp; h, 
         const key_equal&amp; k)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Creates a hash_map with a copy of a range and a bucket count of at
   least <tt>n</tt>, using <tt>h</tt> as the hash function and <tt>k</tt> as the
   key equal function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hash_map(const hash_map&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The copy constructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>hash_map&amp; operator=(const hash_map&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The assignment operator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void swap(hash_map&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two hash_maps.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
pair&lt;iterator, bool&gt;
insert(const value_type&amp; x)
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueAssociativeContainer.html">Unique Associative Container</A>
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> into the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
void insert(InputIterator f, InputIterator l)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueAssociativeContainer.html">Unique Associative Container</A>
</TD>
<TD VAlign=top>
Inserts a range into the <tt>hash_map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void erase(iterator pos)</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Erases the element pointed to by <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type erase(const key_type&amp; k)</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Erases the element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void erase(iterator first, iterator last)</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Erases all elements in a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void clear()</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Erases all of the elements.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator find(const key_type&amp; k) const</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Finds an element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator find(const key_type&amp; k)</tt>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Finds an element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type count(const key_type&amp; k) const</tt>
</TD>
<TD VAlign=top>
 <A href="UniqueAssociativeContainer.html">Unique Associative Container</A>
</TD>
<TD VAlign=top>
Counts the number of elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
pair&lt;const_iterator, const_iterator&gt;
equal_range(const key_type&amp; k) const
</pre>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Finds a range containing all elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
pair&lt;iterator, iterator&gt;
equal_range(const key_type&amp; k)
</pre>
</TD>
<TD VAlign=top>
 <A href="AssociativeContainer.html">Associative Container</A>
</TD>
<TD VAlign=top>
Finds a range containing all elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
data_type&amp; 
operator[](const key_type&amp; k) <A href="#3">[3]</A>
</pre>
</TD>
<TD VAlign=top>
<tt>hash_map</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
bool operator==(const hash_map&amp;, 
                const hash_map&amp;)
</pre>
</TD>
<TD VAlign=top>
 <A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
</TD>
<TD VAlign=top>
Tests two hash_maps for equality.  This is a global function,
   not a member function.
</TD>
</tr>
</table>
<h3>New members</h3>
These members are not defined in the
<A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A> 
and <A href="PairAssociativeContainer.html">Pair Associative Container</A>
requirements, but are specific to
<tt>hash_map</tt>.
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<pre>
data_type&amp; 
operator[](const key_type&amp; k) <A href="#3">[3]</A>
</pre>
</TD>
<TD VAlign=top>
Returns a reference to the object that is associated with
   a particular key.  If the <tt>hash_map</tt> does not already contain such
   an object, <tt>operator[]</tt> inserts the default object <tt>data_type()</tt>. <A href="#3">[3]</A>
</TD>
</tr>
</table>
<h3>Notes</h3>
<P><A name="1">[1]</A>
<tt>Hash_map::iterator</tt> is not a mutable iterator, because
<tt>hash_map::value_type</tt> is not <A href="Assignable.html">Assignable</A>.  That is, if <tt>i</tt> is of
type <tt>hash_map::iterator</tt> and <tt>p</tt> is of type
<tt>hash_map::value_type</tt>, then <tt>*i = p</tt> is not a valid
expression.  However, <tt>hash_map::iterator</tt> isn't a constant
iterator either, because it can be used to modify the object that it
points to.  Using the same notation as above, <tt>(*i).second = p</tt>
is a valid expression.
<P><A name="2">[2]</A>
This member function relies on <i>member template</i> functions, which
at present (early 1998) are not supported by all compilers.  If your
compiler supports member templates, you can call this function with
any type of <A href="InputIterator.html">input iterator</A>.  If your
compiler does not yet support member templates, though, then the
arguments must either be of type <tt>const value_type*</tt> or of type
<tt>hash_map::const_iterator</tt>.
<P><A name="3">[3]</A>
Since <tt>operator[]</tt> might insert a new element into the
<tt>hash_map</tt>, it can't possibly be a <tt>const</tt> member
function.  Note that the definition of <tt>operator[]</tt> is
extremely simple: <tt>m[k]</tt> is equivalent to
<tt>(*((m.insert(value_type(k, data_type()))).first)).second</tt>.
Strictly speaking, this member function is unnecessary: it exists only
for convenience.
<h3>See also</h3>
<A href="AssociativeContainer.html">Associative Container</A>,
<A href="HashedAssociativeContainer.html">Hashed Associative Container</A>, 
<A href="PairAssociativeContainer.html">Pair Associative Container</A>,
<A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>, 
<tt><A href="set.html">set</A></tt>,
<tt><A href="Map.html">map</A></tt>
<tt><A href="multiset.html">multiset</A></tt>,
<tt><A href="Multimap.html">multimap</A></tt>,
<tt><A href="hash_set.html">hash_set</A></tt>, 
<tt><A href="hash_multiset.html">hash_multiset</A></tt>,
<tt><A href="hash_multimap.html">hash_multimap</A></tt>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
