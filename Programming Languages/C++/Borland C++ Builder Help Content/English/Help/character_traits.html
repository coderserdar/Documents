<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>Character Traits</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>Character Traits</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "utilities.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "concept.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: utilities</TD>
<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
</TR>
</Table>

<h3>Description</h3>
Several library components, including <A href="basic_string.html">strings</A>, need to perform
operations on characters.  A Character Traits class is similar to
a <A href="functors.html">function object</A>: it encapsulates some information about a 
particular character type, and some operations on that type.  
<P>
Note that every member of a Character Traits class is static.  
There is never any need to create a Character Traits object, and, in
fact, there is no guarantee that creating such objects is possible.
<h3>Refinement of</h3>
Character Traits is not a refinement of any other concept.
<h3>Associated types</h3>
<Table border>
<TR>
<TD VAlign=top>
Value type
</TD>
<TD VAlign=top>
<tt>X::char_type</tt>
</TD>
<TD VAlign=top>
The character type described by this Character Traits type.
</TD>
</TR>
<TR>
<TD VAlign=top>
Int type
</TD>
<TD VAlign=top>
<tt>X::int_type</tt>
</TD>
<TD VAlign=top>
A type that is capable of representing every valid value of type
   <tt>char_type</tt>, and, additionally an end-of-file value.  For <tt>char</tt>,
   for example, the int type may be <tt>int</tt>, and for <tt>wchar_t</tt> it may 
   be <tt>wint_t</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Position type
</TD>
<TD VAlign=top>
<tt>X::pos_type</tt>
</TD>
<TD VAlign=top>
A type that can represent the position of a character of type
   <tt>char_type</tt> within a file.  This type is usually <tt>streampos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Offset type
</TD>
<TD VAlign=top>
<tt>X::off_type</tt>
</TD>
<TD VAlign=top>
An integer type that can represent the difference between two
   <tt>pos_type</tt> values.  This type is usually <tt>streamoff</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
State type
</TD>
<TD VAlign=top>
<tt>X::state_type</tt>
</TD>
<TD VAlign=top>
A type that can represent a state in a multibyte encoding
   scheme.  This type, if used at all, is usually <tt>mbstate_t</tt>.
</TD>
</tr>
</table>
<h3>Notation</h3>
<Table>
<TR>
<TD VAlign=top>
<tt>X</tt>
</TD>
<TD VAlign=top>
A type that is a model of Character Traits.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c</tt>, <tt>c1</tt>, <tt>c2</tt>
</TD>
<TD VAlign=top>
A value of <tt>X</tt>'s value type, <tt>X::char_type</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>e</tt>, <tt>e1</tt>, <tt>e2</tt>
</TD>
<TD VAlign=top>
A value of <tt>X</tt>'s int type, <tt>X::int_type</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>n</tt>
</TD>
<TD VAlign=top>
A value of type <tt>size_t</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>p</tt>, <tt>p1</tt>, <tt>p2</tt>
</TD>
<TD VAlign=top>
A non-null pointer of type <tt>const X::char_type*</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>s</tt>
</TD>
<TD VAlign=top>
A non-null pointer of type <tt>X::char_type*</tt>.
</TD>
</tr>
</table>
<h3>Valid Expressions</h3>
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Type requirements
</TH>
<TH>
Return type
</TH>
</TR>
<TR>
<TD VAlign=top>
Character assignment
</TD>
<TD VAlign=top>
<tt>X::assign(c1, c2)</tt>
</TD>
<TD VAlign=top>
<tt>c1</tt> is a modifiable lvalue.
</TD>
<TD VAlign=top>
<tt>void</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Character equality
</TD>
<TD VAlign=top>
<tt>X::eq(c1, c2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>bool</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Character comparison
</TD>
<TD VAlign=top>
<tt>X::lt(c1, c2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>bool</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Range comparison
</TD>
<TD VAlign=top>
<tt>X::compare(p1, p2, n)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>int</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Length
</TD>
<TD VAlign=top>
<tt>X::length(p)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>size_t</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Find
</TD>
<TD VAlign=top>
<tt>X::find(p, n, c)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>const X::char_type*</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Move
</TD>
<TD VAlign=top>
<tt>X::move(s, p, n)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::char_type*</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Copy
</TD>
<TD VAlign=top>
<tt>X::copy(s, p, n)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::char_type*</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Range assignment
</TD>
<TD VAlign=top>
<tt>X::assign(s, n, c)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::char_type*</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
EOF value
</TD>
<TD VAlign=top>
<tt>X::eof()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::int_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Not EOF
</TD>
<TD VAlign=top>
<tt>X::not_eof(e)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::int_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Convert to value type
</TD>
<TD VAlign=top>
<tt>X::to_char_type(e)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::char_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Convert to int type
</TD>
<TD VAlign=top>
<tt>X::to_int_type(c)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::int_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal int type values
</TD>
<TD VAlign=top>
<tt>X::eq_int_type(e1, e2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>bool</tt>
</TD>
</tr>
</table>
<h3>Expression semantics</h3>
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Precondition
</TH>
<TH>
Semantics
</TH>
<TH>
Postcondition
</TH>
</TR>
<TR>
<TD VAlign=top>
Character assignment
</TD>
<TD VAlign=top>
<tt>X::assign(c1, c2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Performs the assignment <tt>c1 = c2</tt>
</TD>
<TD VAlign=top>
<tt>X::eq(c1, c2)</tt> is <tt>true</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Character equality
</TD>
<TD VAlign=top>
<tt>X::eq(c1, c2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if and only if <tt>c1</tt> and <tt>c2</tt> are equal.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Character comparison
</TD>
<TD VAlign=top>
<tt>X::lt(c1, c2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if and only if <tt>c1</tt> is less than <tt>c2</tt>.  Note that
   for any two value values <tt>c1</tt> and <tt>c2</tt>, exactly one of 
   <tt>X::lt(c1, c2)</tt>, <tt>X::lt(c2, c1)</tt>, and <tt>X::eq(c1, c2)</tt> should be
   <tt>true</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Range comparison
</TD>
<TD VAlign=top>
<tt>X::compare(p1, p2, n)</tt>
</TD>
<TD VAlign=top>
<tt>[p1, p1+n)</tt> and <tt>[p2, p2+n)</tt> are valid ranges.
</TD>
<TD VAlign=top>
Generalization of <tt>strncmp</tt>.  Returns <tt>0</tt> if every element
   in <tt>[p1, p1+n)</tt> is equal to the corresponding element 
   in <tt>[p2, p2+n)</tt>, a negative value if there exists an element
   in <tt>[p1, p1+n)</tt> less than the corresponding element in <tt>[p2, p2+n)</tt>
   and all previous elements are equal, and a positive value 
   if there exists an element in <tt>[p1, p1+n)</tt> greater than the
   corresponding element in <tt>[p2, p2+n)</tt> and all previous elements
   are equal.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Length
</TD>
<TD VAlign=top>
<tt>X::length(p)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Generalization of <tt>strlen</tt>.
   Returns the smallest non-negative number <tt>n</tt> such that 
   <tt>X::eq(p+n, X::char_type())</tt> is true.  Behavior is undefined
   if no such <tt>n</tt> exists.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Find
</TD>
<TD VAlign=top>
<tt>X::find(p, n, c)</tt>
</TD>
<TD VAlign=top>
<tt>[p, p+n)</tt> is a valid range.
</TD>
<TD VAlign=top>
Generalization of <tt>strchr</tt>.  Returns the first pointer <tt>q</tt>
   in <tt>[p, p+n)</tt> such that <tt>X::eq(*q, c)</tt> is true.  Returns a 
   null pointer if no such pointer exists.  (Note that this method
   for indicating a failed search differs from that is 
   <tt><A href="find.html">find</A></tt>.)
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Move
</TD>
<TD VAlign=top>
<tt>X::move(s, p, n)</tt>
</TD>
<TD VAlign=top>
<tt>[p, p+n)</tt> and <tt>[s, s+n)</tt> are valid ranges (possibly overlapping).
</TD>
<TD VAlign=top>
Generalization of <tt>memmove</tt>.  Copies values from the range
   <tt>[p, p+n)</tt> to the range <tt>[s, s+n)</tt>, and returns <tt>s</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Copy
</TD>
<TD VAlign=top>
<tt>X::copy(s, p, n)</tt>
</TD>
<TD VAlign=top>
<tt>[p, p+n)</tt> and <tt>[s, s+n)</tt> are valid ranges which do not overlap.
</TD>
<TD VAlign=top>
Generalization of <tt>memcpy</tt>.  Copies values from the range
   <tt>[p, p+n)</tt> to the range <tt>[s, s+n)</tt>, and returns <tt>s</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Range assignment
</TD>
<TD VAlign=top>
<tt>X::assign(s, n, c)</tt>
</TD>
<TD VAlign=top>
<tt>[s, s+n)</tt> is a valid range.
</TD>
<TD VAlign=top>
Generalization of <tt>memset</tt>.  Assigns the value <tt>c</tt> to each pointer
   in the range <tt>[s, s+n)</tt>, and returns <tt>s</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
EOF value
</TD>
<TD VAlign=top>
<tt>X::eof()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns a value that can represent EOF.
</TD>
<TD VAlign=top>
<tt>X::eof()</tt> is distinct from every valid value of type
   <tt>X::char_type</tt>.  That is, there exists no value <tt>c</tt>
   such that <tt>X::eq_int_type(X::to_int_type(c), X::eof())</tt> is <tt>true</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Not EOF
</TD>
<TD VAlign=top>
<tt>X::not_eof(e)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns <tt>e</tt> if <tt>e</tt> represents a valid <tt>char_type</tt> value, and some
   non-EOF value if <tt>e</tt> is <tt>X::eof()</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Convert to value type
</TD>
<TD VAlign=top>
<tt>X::to_char_type(e)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Converts <tt>e</tt> to <tt>X</tt>'s int type.  If <tt>e</tt> is a representation of some
   <tt>char_type</tt> value then it returns that value; if <tt>e</tt> is <tt>X::eof()</tt>
   then the return value is unspecified.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Convert to int type
</TD>
<TD VAlign=top>
<tt>X::to_int_type(c)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Converts <tt>c</tt> to <tt>X</tt>'s int type.
</TD>
<TD VAlign=top>
<tt>X::to_char_type(X::to_int_type(c))</tt> is a null operation.
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal int type values
</TD>
<TD VAlign=top>
<tt>X::eq_int_type(e1, e2)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Compares two int type values.  If there exist values of type
   <tt>X::char_type</tt> such that <tt>e1</tt> is <tt>X::to_int_type(c1))</tt> and
   <tt>e2</tt> is <tt>X::to_int_type(c2))</tt>, then <tt>X::eq_int_type(e1, e2)</tt> is
   the same as <tt>X::eq(c1, c2)</tt>.  Otherwise, <tt>eq_int_type</tt> returns
   <tt>true</tt> if <tt>e1</tt> and <tt>e2</tt> are both EOF and <tt>false</tt> if one of
   <tt>e1</tt> and <tt>e2</tt> is EOF and the other is not.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Complexity guarantees</h3>
<tt>length</tt>, <tt>find</tt>, <tt>move</tt>, <tt>copy</tt>, and the range version of <tt>assign</tt>
are linear in <tt>n</tt>.
<P>
All other operations are constant time.
<h3>Models</h3>
<UL>
<LI>
<tt><A href="char_traits.html">char_traits</A>&lt;char&gt;</tt>
<LI>
<tt><A href="char_traits.html">char_traits</A>&lt;wchar_t&gt;</tt>
</UL>
<h3>Notes</h3>
<h3>See also</h3>
<tt><A href="basic_string.html">string</A></tt>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
