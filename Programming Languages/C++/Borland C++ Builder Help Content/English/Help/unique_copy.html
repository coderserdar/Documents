<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>unique_copy</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>unique_copy</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "algorithms.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "function.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
<TD Align=right VAlign=top><b>Component type</b>: function</TD>
</TR>
</Table>

<h3>Prototype</h3>
<tt>Unique_copy</tt> is an overloaded name; there are
actually two <tt>unique_copy</tt> functions.
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>, class <A href="OutputIterator.html">OutputIterator</A>&gt;
OutputIterator unique_copy(InputIterator first, InputIterator last,
                           OutputIterator result);

template &lt;class <A href="InputIterator.html">InputIterator</A>, class <A href="OutputIterator.html">OutputIterator</A>, class <A href="BinaryPredicate.html">BinaryPredicate</A>&gt;
OutputIterator unique_copy(InputIterator first, InputIterator last,
                           OutputIterator result,
                           BinaryPredicate binary_pred);
</pre>                   
<h3>Description</h3>
<tt>Unique_copy</tt> copies elements from the range <tt>[first, last)</tt> to a 
range beginning with <tt>result</tt>, except that in a consecutive group of 
duplicate elements only the first one is copied.  The return value is
the end of the range to which the elements are copied.  This behavior 
is similar to the Unix filter <tt>uniq</tt>.
<P>
The reason there are two different versions of <tt>unique_copy</tt> is that there
are two different definitions of what it means for a consecutive group
of elements to be duplicates.  In the first version, the test is
simple equality: the elements in a range <tt>[f, l)</tt> are duplicates if,
for every iterator <tt>i</tt> in the range, either <tt>i == f</tt> or else <tt>*i == *(i-1)</tt>.
In the second, the test is an arbitrary <A href="BinaryPredicate.html">Binary Predicate</A>
<tt>binary_pred</tt>: the elements in <tt>[f, l)</tt> are duplicates if, for every 
iterator <tt>i</tt> in the range, either <tt>i == f</tt> or else
<tt>binary_pred(*i, *(i-1))</tt> is <tt>true</tt>. <A href="#1">[1]</A>
<h3>Definition</h3>
Defined in the standard header <A href="algorithm">algorithm</A>, and in the nonstandard
backward-compatibility header <A href="algo.h">algo.h</A>.
<h3>Requirements on types</h3>
For the first version:
<UL>
<LI>
<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator</tt>'s value type is <A href="EqualityComparable.html">Equality Comparable</A>.
<LI>
<tt>OutputIterator</tt> is a model of <A href="OutputIterator.html">Output Iterator</A>.
<LI>
<tt>InputIterator</tt>'s value type is convertible to a type in
   <tt>OutputIterator</tt>'s set of value types.
</UL>
For the second version:
<UL>
<LI>
<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary Predicate</A>. <A href="#2">[2]</A>
<LI>
<tt>InputIterator</tt>'s value type is convertible to
   first argument type and to <tt>BinaryPredicate</tt>'s second argument type.
<LI>
<tt>OutputIterator</tt> is a model of <A href="OutputIterator.html">Output Iterator</A>.
<LI>
<tt>InputIterator</tt>'s value type is convertible to a type in
   <tt>OutputIterator</tt>'s set of value types.
</UL>
<h3>Preconditions</h3>
<UL>
<LI>
<tt>[first, last)</tt> is a valid range.
<LI>
There is enough space to hold all of the elements being copied.
   More formally, if there are <tt>n</tt> elements in the range 
   <tt>[first, last)</tt> after duplicates are removed from consecutive groups,
   then <tt>[result, result + n)</tt> must be a valid range.
</UL>
<h3>Complexity</h3>
Linear.  Exactly <tt>last - first</tt> applications of <tt>operator==</tt>
(in the case of the first version of <tt>unique</tt>) or of <tt>binary_pred</tt>
(in the case of the second version), and at most <tt>last - first</tt>
assignments.
<h3>Example</h3>
Print all of the numbers in an array, but only print the first one
in a consecutive group of identical numbers.
<pre>
const int A[] = {2, 7, 7, 7, 1, 1, 8, 8, 8, 2, 8, 8};
unique_copy(A, A + sizeof(A) / sizeof(int), 
            <A href="ostream_iterator.html">ostream_iterator</A>&lt;int&gt;(cout, &quot; &quot;));
// The output is &quot;2 7 1 8 2 8&quot;.
</pre>
<h3>Notes</h3>
<P><A name="1">[1]</A>
Strictly speaking, the first version of <tt>unique_copy</tt> is redundant:
you can achieve the same functionality by using an object of class
<tt><A href="equal_to.html">equal_to</A></tt> as the <A href="BinaryPredicate.html">Binary Predicate</A> argument.  The first version
is provided strictly for the sake of convenience: testing for equality
is an important special case.
<P><A name="2">[2]</A>
<tt>BinaryPredicate</tt> is not required to be an equivalence
relation.  You should be cautious, though, about using <tt>unique_copy</tt> with a
<A href="BinaryPredicate.html">Binary Predicate</A> that is not an equivalence relation: you could
easily get unexpected results.
<h3>See also</h3>
<A href="BinaryPredicate.html">Binary Predicate</A>, <tt><A href="unique.html">unique</A></tt>, <tt><A href="remove_copy.html">remove_copy</A></tt>, <tt><A href="remove_copy_if.html">remove_copy_if</A></tt>,
<tt><A href="adjacent_find.html">adjacent_find</A></tt>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
