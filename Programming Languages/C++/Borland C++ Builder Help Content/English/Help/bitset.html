<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>bitset&lt;N&gt;</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>bitset&lt;N&gt;</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "containers.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "type.gif" Alt=""   WIDTH = "194"  HEIGHT = "39" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
<tt>Bitset</tt> is very similar to <A href="Vector.html">vector</A>&lt;bool&gt; (also known as
<A href="bit_vector.html">bit_vector</A>): it contains a collection of bits, and provides
constant-time access to each bit.  There are two main differences
between <tt>bitset</tt> and <tt>vector&lt;bool&gt;</tt>.  First, the size of a <tt>bitset</tt>
cannot be changed: <tt>bitset</tt>'s template parameter <tt>N</tt>, which specifies
the number of bits in the bitset, must be an integer constant.
Second, <tt>bitset</tt> is not a <A href="Sequence.html">Sequence</A>; in fact, it is not an STL
<A href="Container.html">Container</A> at all.  It does not have iterators, for example, or
<tt>begin()</tt> and <tt>end()</tt> member functions.  Instead, <tt>bitset</tt>'s interface
resembles that of unsigned integers.  It defines bitwise arithmetic
operators such as <tt>&amp;=</tt>, <tt>|=</tt>, and <tt>^=</tt>.
<P>
In general, bit <tt>0</tt> is the least significant bit and bit <tt>N-1</tt> is the
most significant bit.
<h3>Example</h3>
<pre>
int main() {
  const bitset&lt;12&gt; mask(2730ul); 
  cout &lt;&lt; &quot;mask =      &quot; &lt;&lt; mask &lt;&lt; endl;

  bitset&lt;12&gt; x;

  cout &lt;&lt; &quot;Enter a 12-bit bitset in binary: &quot; &lt;&lt; flush;
  if (cin &gt;&gt; x) {
    cout &lt;&lt; &quot;x =        &quot; &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; &quot;As ulong:  &quot; &lt;&lt; x.to_ulong() &lt;&lt; endl;
    cout &lt;&lt; &quot;And with mask: &quot; &lt;&lt; (x &amp; mask) &lt;&lt; endl;
    cout &lt;&lt; &quot;Or with mask:  &quot; &lt;&lt; (x | mask) &lt;&lt; endl;
  }
}
</pre>
<h3>Definition</h3>
Defined in the standard header <A href="bitset">bitset</A>.
<h3>Template parameters</h3>
<Table border>
<TR>
<TH>
Parameter
</TH>
<TH>
Description
</TH>
<TH>
Default
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>N</tt>
</TD>
<TD VAlign=top>
A nonzero constant of type <tt>size_t</tt>: the number of bits that the
   bitset contains.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Model of</h3>
<A href="Assignable.html">Assignable</A>, <A href="DefaultConstructible.html">Default Constructible</A>, <A href="EqualityComparable.html">Equality Comparable</A>
<h3>Type requirements</h3>
<tt>N</tt> is a constant integer expression of a type convertible to
<tt>size_t</tt>, and <tt>N</tt> is a positive number.
<h3>Public base classes</h3>
None.
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>reference</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
A proxy class that acts as a reference to a single bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset()</tt>
</TD>
<TD VAlign=top>
 <A href="DefaultConstructible.html">Default Constructible</A>
</TD>
<TD VAlign=top>
The default constructor.  All bits are initially zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset(unsigned long val)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Conversion from unsigned long.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Assignable.html">Assignable</A>
</TD>
<TD VAlign=top>
Copy constructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Assignable.html">Assignable</A>
</TD>
<TD VAlign=top>
Assignment operator.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template&lt;class Char, class Traits, class Alloc&gt;
explicit
bitset(const <A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt;&amp; s,
       size_t pos = 0,
       size_t n = 
         <A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt;::npos) 
</pre>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Conversion from string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&amp;=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise and.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator|=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise inclusive or.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator^=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise exclusive or.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&lt;&lt;=(size_t)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Left shift.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&gt;&gt;=(size_t)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Right shift.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&lt;&lt;(size_t n) const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> shifted left by <tt>n</tt> bits.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&gt;&gt;(size_t n) const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> shifted right by <tt>n</tt> bits.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; set()</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Sets every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; flip()</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Flips the value of every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator~() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> with all of its bits flipped.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; reset()</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Clears every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; set(size_t n, int val = 1)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Sets bit <tt>n</tt> if <tt>val</tt> is nonzero, and clears bit <tt>n</tt> if <tt>val</tt> is zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; reset(size_t n)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Clears bit <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset flip(size_t n)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Flips bit <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_t size() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns <tt>N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_t count() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns the number of bits that are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool any() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if any bits are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool none() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if no bits are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool test(size_t n) const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if bit <tt>n</tt> is set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reference operator[](size_t n)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns a <tt>reference</tt> to bit <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool operator[](size_t n) const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if bit <tt>n</tt> is set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>unsigned long to_ulong() const</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns an <tt>unsigned long</tt> corresponding to the bits in <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template&lt;class Char, class Traits, class Alloc&gt;
<A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt; to_string() const
</pre>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Returns a string representation of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool operator==(const bitset&amp;) const</tt>
</TD>
<TD VAlign=top>
 <A href="EqualityComparable.html">Equality Comparable</A>
</TD>
<TD VAlign=top>
The equality operator.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool operator!=(const bitset&amp;) const</tt>
</TD>
<TD VAlign=top>
 <A href="EqualityComparable.html">Equality Comparable</A>
</TD>
<TD VAlign=top>
The inequality operator.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&amp;(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise and of two bitsets.  This is a global function,
   not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator|(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise or of two bitsets.  This is a global function,
   not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator^(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Bitwise exclusive or of two bitsets.  This is a global function,
   not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class Char, class Traits, 
          size_t N&gt;
basic_istream&lt;Char,Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;Char,Traits&gt;&amp;, 
           bitset&lt;N&gt;&amp;)
</pre>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Extract a <tt>bitset</tt> from an input stream.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class Char, class Traits, 
          size_t N&gt;
basic_ostream&lt;Char,Traits&gt;&amp;
operator&gt;&gt;(basic_ostream&lt;Char,Traits&gt;&amp;, 
           const bitset&lt;N&gt;&amp;)
</pre>
</TD>
<TD VAlign=top>
<tt>bitset</tt>
</TD>
<TD VAlign=top>
Output a <tt>bitset</tt> to an output stream.
</TD>
</tr>
</table>
<h3>New members</h3>
These members are not defined in the 
<A href="Assignable.html">Assignable</A>, <A href="DefaultConstructible.html">Default Constructible</A>, or <A href="EqualityComparable.html">Equality Comparable</A>
requirements, but are specific to <tt>bitset</tt>.
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>reference</tt>
</TD>
<TD VAlign=top>
A proxy class that acts as a reference to a single bit.  It contains
   an assignment operator, a conversion to <tt>bool</tt>, an <tt>operator~</tt>, and
   a member function <tt>flip</tt>.  It exists only as a helper class for 
   <tt>bitset</tt>'s <tt>operator[]</tt>.  That is, it supports the expressions
   <tt>x = b[i]</tt>, <tt>b[i] = x</tt>, <tt>b[i] = b[j]</tt>, <tt>x = ~b[i]</tt>, and 
   <tt>b[i].flip()</tt>.  (Where <tt>b</tt> is a <tt>bitset</tt> and <tt>x</tt> is a <tt>bool</tt>.)
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset(unsigned long val)</tt>
</TD>
<TD VAlign=top>
Conversion from unsigned long.  Constructs a bitset, initializing
   the first <tt>min(N, sizeof(unsigned long) * CHAR_BIT)</tt> bits to the
   corresponding bits in <tt>val</tt> and all other bits, if any, to zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template&lt;class Char, class Traits, class Alloc&gt;
explicit 
bitset(const <A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt;&amp; s,
       size_t pos = 0,
       size_t n = 
         <A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt;::npos) 
</pre>
</TD>
<TD VAlign=top>
Conversion from string.  Constructs a bitset, initializing the
   first <tt>M</tt> bits to the corresponding   characters in <tt>s</tt>, where
   <tt>M</tt> is defined as <tt>min(N, min(s.size() - pos, n))</tt>.
   Note that the <i>highest</i> character position in <tt>s</tt>, not the
   lowest, corresponds to the least significant bit.
   That is, character position <tt>pos + M - 1 - i</tt> corresponds to bit <tt>i</tt>.
   So, for example, <tt>bitset(string(&quot;1101&quot;))</tt> is the same as
   <tt>bitset(13ul)</tt>.  This function throws <tt>out_of_range</tt> if 
   <tt>pos &gt; s.size()</tt>, and <tt>invalid_argument</tt> if any of the characters
   used to initialize the bits are anything other than <tt>0</tt> or <tt>1</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&amp;=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise and.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator|=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise inclusive or.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator^=(const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise exclusive or.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&lt;&lt;=(size_t n)</tt>
</TD>
<TD VAlign=top>
Left shift, where bit <tt>0</tt> is considered the least significant bit.
   Bit <tt>i</tt> takes on the previous value of bit <tt>i - n</tt>, or zero if no
   such bit exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; operator&gt;&gt;=(size_t n)</tt>
</TD>
<TD VAlign=top>
Right shift, where bit <tt>0</tt> is considered the least significant bit.
   Bit <tt>i</tt> takes on the previous value of bit <tt>i + n</tt>, or zero if no
   such bit exists.   
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&lt;&lt;(size_t n) const</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> shifted left by <tt>n</tt> bits.
   Note that the expression <tt>b &lt;&lt; n</tt> is equivalent to 
   constructing a temporary copy of <tt>b</tt>
   and then using <tt>operator&lt;&lt;=</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&gt;&gt;(size_t n) const</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> shifted right by <tt>n</tt> bits.
   Note that the expression <tt>b &gt;&gt; n</tt> is equivalent to 
   constructing a temporary copy of <tt>b</tt>
   and then using <tt>operator&gt;&gt;=</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; set()</tt>
</TD>
<TD VAlign=top>
Sets every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; flip()</tt>
</TD>
<TD VAlign=top>
Flips the value of every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator~() const</tt>
</TD>
<TD VAlign=top>
Returns a copy of <tt>*this</tt> with all of its bits flipped.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; reset()</tt>
</TD>
<TD VAlign=top>
Clears every bit.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; set(size_t n, int val = 1)</tt>
</TD>
<TD VAlign=top>
Sets bit <tt>n</tt> if <tt>val</tt> is nonzero, and clears bit <tt>n</tt> if <tt>val</tt> is zero.
   Throws <tt>out_of_range</tt> if <tt>n &gt;= N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset&amp; reset(size_t n)</tt>
</TD>
<TD VAlign=top>
Clears bit <tt>n</tt>.
   Throws <tt>out_of_range</tt> if <tt>n &gt;= N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset flip(size_t n)</tt>
</TD>
<TD VAlign=top>
Flips bit <tt>n</tt>.
   Throws <tt>out_of_range</tt> if <tt>n &gt;= N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_t size() const</tt>
</TD>
<TD VAlign=top>
Returns <tt>N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_t count() const</tt>
</TD>
<TD VAlign=top>
Returns the number of bits that are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool any() const</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if any bits are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool none() const</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if no bits are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool test(size_t n) const</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if bit <tt>n</tt> is set.
   Throws <tt>out_of_range</tt> if <tt>n &gt;= N</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reference operator[](size_t n)</tt>
</TD>
<TD VAlign=top>
Returns a <tt>reference</tt> to bit <tt>n</tt>.  Note that <tt>reference</tt> is a
   proxy class with an assignment operator and a conversion to <tt>bool</tt>,
   which allows you to use <tt>operator[]</tt> for assignment.  That is, you
   can write both <tt>x = b[n]</tt> and <tt>b[n] = x</tt>.  
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool operator[](size_t n) const</tt>
</TD>
<TD VAlign=top>
Returns <tt>true</tt> if bit <tt>n</tt> is set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>unsigned long to_ulong() const</tt>
</TD>
<TD VAlign=top>
Returns an <tt>unsigned long</tt> corresponding to the bits in <tt>*this</tt>.
   Throws <tt>overflow_error</tt> if it is impossible to represent <tt>*this</tt> as
   an <tt>unsigned long</tt>.  (That is, if <tt>N</tt> is larger than the number of
   bits in an <tt>unsigned long</tt> and if any of the high-order bits are set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template&lt;class Char, class Traits, class Alloc&gt;
<A href="basic_string.html">basic_string</A>&lt;Char,Traits,Alloc&gt; to_string() const
</pre>
</TD>
<TD VAlign=top>
Returns a string representation of <tt>*this</tt>: each character is
   <tt>1</tt> if the corresponding bit is set, and <tt>0</tt> if it is not.
   In general, character position <tt>i</tt> corresponds to bit position
   <tt>N - 1 - i</tt>.  Note that this member function relies on two 
   language features, <i>member templates</i> and <i>explicit function
   template argument specification</i>, that are not yet universally
   available; this member function is disabled for compilers that do
   not support those features.  Note also that the syntax for calling
   this member function is somewhat cumbersome.  To convert a bitset <tt>b</tt>
   to an ordinary string, you must write 
<pre>
b.template to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;()
</pre>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator&amp;(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise and of two bitsets.  This is a global function,
   not a member function.  Note that the expression <tt>b1 &amp; b2</tt>
   is equivalent to creating a temporary copy of <tt>b1</tt>, using
   <tt>operator&amp;=</tt>, and returning the temporary copy.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator|(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise or of two bitsets.  This is a global function,
   not a member function.  Note that the expression <tt>b1 | b2</tt>
   is equivalent to creating a temporary copy of <tt>b1</tt>, using
   <tt>operator|=</tt>, and returning the temporary copy.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bitset operator^(const bitset&amp;, const bitset&amp;)</tt>
</TD>
<TD VAlign=top>
Bitwise exclusive or of two bitsets.  This is a global function,
   not a member function.  Note that the expression <tt>b1 ^ b2</tt>
   is equivalent to creating a temporary copy of <tt>b1</tt>, using
   <tt>operator^=</tt>, and returning the temporary copy.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class Char, class Traits, 
          size_t N&gt;
basic_istream&lt;Char, Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;Char,Traits&gt;&amp; is, 
           bitset&lt;N&gt;&amp; x)
</pre>
</TD>
<TD VAlign=top>
Extract a <tt>bitset</tt> from an input stream.  This function first
   skips whitespace, then extracts up to <tt>N</tt> characters from the
   input stream.  It stops either when it has successfully 
   extracted <tt>N</tt> character, or when extraction fails, or when
   it sees a character that is something other than <tt>1</tt> (in which 
   case it does not extract that character).  It then assigns a
   value to the <tt>bitset</tt> in the same way as if it were initializing
   the <tt>bitset</tt> from a string.  So, for example, if the input stream
   contains the characters <tt>&quot;1100abc&quot;</tt>, it will assign the value
   <tt>12ul</tt> to the <tt>bitset</tt>, and the next character read from the input
   stream will be <tt>a</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class Char, class Traits, 
          size_t N&gt;
basic_ostream&lt;Char,Traits&gt;&amp;
operator&gt;&gt;(basic_ostream&lt;Char,Traits&gt;&amp; os, 
           const bitset&lt;N&gt;&amp; x)
</pre>
</TD>
<TD VAlign=top>
Output a <tt>bitset</tt> to an output stream.  This function behaves as
   if it converts the <tt>bitset</tt> to a string and then writes that string
   to the output stream.  That is, it is equivalent to
<pre>
os &lt;&lt; x.template to_string&lt;Char,Traits,allocator&lt;Char&gt; &gt;()
</pre>
</TD>
</tr>
</table>
<h3>Notes</h3>
<h3>See also</h3>
<tt><A href="Vector.html">vector</A></tt>, <tt><A href="bit_vector.html">bit_vector</A></tt>, <tt><A href="basic_string.html">string</A></tt>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
