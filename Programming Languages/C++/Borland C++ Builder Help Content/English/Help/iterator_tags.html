<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>Iterator Tags</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>Iterator Tags</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "iterators.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "overview.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
<TD Align=right VAlign=top><b>Component type</b>: overview</TD>
</TR>
</Table>

<h3>Summary</h3>
Iterator tag functions are a method for accessing information that is
associated with iterators.  Specifically, an iterator type must, as
discussed in the <A href="InputIterator.html">Input Iterator</A> requirements, have an
associated <i>distance type</i> and <i>value type</i>. <A href="#1">[1]</A>  It is sometimes
important for an algorithm parameterized by an iterator type to be
able to determine the distance type and value type.  Iterator tags
also allow algorithms to determine an iterator's category, so that
they can take different actions depending on whether an iterator is an
<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="ForwardIterator.html">Forward Iterator</A>,
<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, or <A href="RandomAccessIterator.html">Random Access Iterator</A>.
<P>
Note that the iterator tag functions <tt><A href="distance_type.html">distance_type</A></tt>,
<tt><A href="value_type.html">value_type</A></tt>, and <tt><A href="iterator_category.html">iterator_category</A></tt> are an older method of
accessing the type information associated with iterators: they were
defined in the original STL.  The draft C++ standard, however, defines
a different and more convenient mechanism: <tt><A href="iterator_traits.html">iterator_traits</A></tt>.
Both mechanisms are supported <A href="#2">[2]</A>, for reasons of backwards
compatibility, but the older mechanism will eventually be
removed.
<h3>Description</h3>
The basic idea of the iterator tag functions, and of
<tt><A href="iterator_traits.html">iterator_traits</A></tt>, is quite simple: iterators have associated type
information, and there must be a way to access that information.
Specifically, iterator tag functions and <tt><A href="iterator_traits.html">iterator_traits</A></tt> are
used to determine an iterator's value type, distance type, and
iterator category.
<P>
An iterator's <i>category</i> is the most specific concept that it is a
model of: <A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="ForwardIterator.html">Forward Iterator</A>, 
<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, or <A href="RandomAccessIterator.html">Random Access Iterator</A>.
This information is expressed in the C++ type system by defining five
category tag types, <tt><A href="input_iterator_tag.html">input_iterator_tag</A></tt>,
<tt><A href="output_iterator_tag.html">output_iterator_tag</A></tt>, <tt><A href="forward_iterator_tag.html">forward_iterator_tag</A></tt>,
<tt><A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A></tt>, and
<tt><A href="random_access_iterator_tag.html">random_access_iterator_tag</A></tt>, each of which corresponds to one of
those concepts. <A href="#3">[3]</A> 
<P>
The function <tt><A href="iterator_category.html">iterator_category</A></tt> takes a single argument, an
iterator, and returns the tag corresponding to that iterator's
category.  That is, it returns a <tt><A href="random_access_iterator_tag.html">random_access_iterator_tag</A></tt> if
its argument is a pointer, a <tt><A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A></tt> if its
argument is a <tt><A href="List.html">list</A>::iterator</tt>, and so on.  <tt>Iterator_traits</tt>
provides the same information in a slightly different way: if <tt>I</tt> is
an iterator, then <tt><A href="iterator_traits.html">iterator_traits</A>&lt;I&gt;::iterator_category</tt> is a nested
<tt>typedef</tt>: it is one of the five category tag types.
<P>
An iterator's <i>value type</i> is the type of object that is returned
when the iterator is dereferenced.  (See the discussion in the
<A href="InputIterator.html">Input Iterator</A> requirements.)  Ideally, one might want
<tt><A href="value_type.html">value_type</A></tt> to take a single argument, an iterator, and return
the iterator's value type.  Unfortunately, that's impossible:
a function must return an object, and types aren't objects.  Instead,
<tt><A href="value_type.html">value_type</A></tt> returns the value <tt>(T*) 0</tt>, where <tt>T</tt> is the 
argument's value type.  The <tt>iterator_traits</tt> class, however,
does not have this restriction: <tt>iterator_traits&lt;I&gt;::value_type</tt>
is a type, not a value.  It is a nested <tt>typedef</tt>, and it can be
used in declarations of variables, as an function's argument type or 
return type, and in any other ways that C++ types can be used.
<P>
(Note that the function <tt><A href="value_type.html">value_type</A></tt> need
not be defined for <A href="OutputIterator.html">Output Iterators</A>, since an <A href="OutputIterator.html">Output Iterator</A>
need not have a value type.  Similarly, <tt><A href="iterator_traits.html">iterator_traits</A>&lt;I&gt;::value_type</tt>
is typically defined as <tt>void</tt> when <tt>I</tt> is an output iterator)
<P>
An iterator's <i>distance type</i>, or <i>difference type</i> (the terms
are synonymous) is the type that is used to represent the distance
between two iterators.  (See the discussion in the <A href="InputIterator.html">Input Iterator</A>
requirements.)  The function <tt><A href="distance_type.html">distance_type</A></tt> returns this
information in the same form that <tt><A href="value_type.html">value_type</A></tt> does: its argument
is an iterator, and it returns the value <tt>(Distance*) 0</tt>, where
<tt>Distance</tt> is the iterator's distance type.  Similarly,
<tt><A href="iterator_traits.html">iterator_traits</A>&lt;I&gt;::difference_type</tt> is <tt>I</tt>'s distance type.
<P>
Just as with <tt><A href="value_type.html">value_type</A></tt>, the function <tt><A href="distance_type.html">distance_type</A></tt> need
not be defined for <A href="OutputIterator.html">Output Iterators</A>, and, if <tt>I</tt> is an 
<A href="OutputIterator.html">Output Iterator</A>, <tt><A href="iterator_traits.html">iterator_traits</A>&lt;I&gt;::difference_type</tt>
may be defined as <tt>void</tt>.  An <A href="OutputIterator.html">Output Iterator</A>
need not have a distance type.
<P>
The functions <tt><A href="iterator_category.html">iterator_category</A></tt>, <tt><A href="value_type.html">value_type</A></tt>, and
<tt><A href="distance_type.html">distance_type</A></tt> must be provided for every type of iterator.
(Except, as noted above, that <tt><A href="value_type.html">value_type</A></tt> and <tt><A href="distance_type.html">distance_type</A></tt>
need not be provided for <A href="OutputIterator.html">Output Iterators</A>.)  In principle, this is
simply a matter of overloading: anyone who defines a new iterator type
must define those three functions for it.  In practice, there's a
slightly more convenient method.  The STL defines five base classes,
<tt><A href="output_iterator.html">output_iterator</A></tt>, <tt><A href="input_iterator.html">input_iterator</A></tt>, <tt><A href="forward_iterator.html">forward_iterator</A></tt>,
<tt><A href="bidirectional_iterator.html">bidirectional_iterator</A></tt>, and <tt><A href="random_access_iterator.html">random_access_iterator</A></tt>.  The
functions <tt><A href="iterator_category.html">iterator_category</A></tt>, <tt><A href="value_type.html">value_type</A></tt>, and
<tt><A href="distance_type.html">distance_type</A></tt> are defined for those base classes.  The effect,
then, is that if you are defining a new type of iterator you can
simply derive it from one of those base classes, and the iterator tag
functions will automatically be defined correctly.  These base classes
contain no member functions or member variables, so deriving from one
of them ought not to incur any overhead.  
<P>
(Again, note that base classes are provided solely for the
convenience of people who define iterators.  If you define a class
<tt>Iter</tt> that is a new kind of <A href="BidirectionalIterator.html">Bidirectional Iterator</A>, you do not
have to derive it from the base class <tt><A href="bidirectional_iterator.html">bidirectional_iterator</A></tt>.  You
do, however, have to make sure that <tt><A href="iterator_category.html">iterator_category</A></tt>,
<tt><A href="value_type.html">value_type</A></tt>, and <tt><A href="distance_type.html">distance_type</A></tt> are defined correctly for
arguments of type <tt>Iter</tt>, and deriving <tt>Iter</tt> from
<tt><A href="bidirectional_iterator.html">bidirectional_iterator</A></tt> is usually the most convenient way to do
that.)
<h3>Examples</h3>
This example uses the <tt><A href="value_type.html">value_type</A></tt> iterator tag function in order
to declare a temporary variable of an iterator's value type.  Note the
use of an auxiliary function, <tt>__iter_swap</tt>.  This is a very common
idiom: most uses of iterator tags involve auxiliary functions.  
<pre>
    template &lt;class <A href="ForwardIterator.html">ForwardIterator</A>1, class <A href="ForwardIterator.html">ForwardIterator</A>2, class ValueType&gt;
    inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, ValueType*) {
	ValueType tmp = *a;
	*a = *b;
	*b = tmp;
    }

    template &lt;class <A href="ForwardIterator.html">ForwardIterator</A>1, class <A href="ForwardIterator.html">ForwardIterator</A>2&gt;
    inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
	__iter_swap(a, b, <A href="value_type.html">value_type</A>(a));
    }
</pre>
<P>
This example does exactly the same thing, using <tt><A href="iterator_traits.html">iterator_traits</A></tt>
instead.  Note how much simpler it is: the auxiliary function is
no longer required.
<pre>
    template &lt;class <A href="ForwardIterator.html">ForwardIterator</A>1, class <A href="ForwardIterator.html">ForwardIterator</A>2&gt;
    inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
        <A href="iterator_traits.html">iterator_traits</A>&lt;ForwardIterator1&gt;::value_type tmp = *a;
        *a = *b;
        *b = tmp;    
    }
</pre>
<P>
This example uses the <tt><A href="iterator_category.html">iterator_category</A></tt>
iterator tag function: <tt><A href="reverse.html">reverse</A></tt> can be implemented for either
<A href="BidirectionalIterator.html">Bidirectional Iterator</A>s or for <A href="RandomAccessIterator.html">Random Access Iterators</A>,
but the algorithm for <A href="RandomAccessIterator.html">Random Access Iterators</A> is more efficient.
Consequently, <tt><A href="reverse.html">reverse</A></tt> is written to dispatch on the iterator
category.  This dispatch takes place at compile time, and should not
incur any run-time penalty.
<pre>
    template &lt;class <A href="BidirectionalIterator.html">BidirectionalIterator</A>&gt;
    void __reverse(BidirectionalIterator first, BidirectionalIterator last, 
		   <A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A>) {
	while (true)
	    if (first == last || first == --last)
		return;
	    else
		iter_swap(first++, last);
    }

    template &lt;class <A href="RandomAccessIterator.html">RandomAccessIterator</A>&gt;
    void __reverse(RandomAccessIterator first, RandomAccessIterator last,
		   <A href="random_access_iterator_tag.html">random_access_iterator_tag</A>) {
	while (first &lt; last) iter_swap(first++, --last);
    }

    template &lt;class <A href="BidirectionalIterator.html">BidirectionalIterator</A>&gt;
    inline void <A href="reverse.html">reverse</A>(BidirectionalIterator first, BidirectionalIterator last) {
	__reverse(first, last, <A href="iterator_category.html">iterator_category</A>(first));
    }
</pre>
<P>
In this case, <tt><A href="iterator_traits.html">iterator_traits</A></tt> would not be different in any
substantive way: it would still be necessary to use auxiliary 
functions to dispatch on the iterator category.  The only difference
is changing the top-level function to 
<pre>
    template &lt;class <A href="BidirectionalIterator.html">BidirectionalIterator</A>&gt;
    inline void <A href="reverse.html">reverse</A>(BidirectionalIterator first, BidirectionalIterator last) {
	__reverse(first, last, 
                  <A href="iterator_traits.html">iterator_traits</A>&lt;first&gt;::iterator_category());
    }
</pre>
<h3>Concepts</h3>
<h3>Types</h3>
<UL>
<LI>
<tt><A href="output_iterator.html">output_iterator</A></tt>
<LI>
<tt><A href="input_iterator.html">input_iterator</A></tt>
<LI>
<tt><A href="forward_iterator.html">forward_iterator</A></tt>
<LI>
<tt><A href="bidirectional_iterator.html">bidirectional_iterator</A></tt>
<LI>
<tt><A href="random_access_iterator.html">random_access_iterator</A></tt>
</UL>
<UL>
<LI>
<tt><A href="output_iterator_tag.html">output_iterator_tag</A></tt>
<LI>
<tt><A href="input_iterator_tag.html">input_iterator_tag</A></tt>
<LI>
<tt><A href="forward_iterator_tag.html">forward_iterator_tag</A></tt>
<LI>
<tt><A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A></tt>
<LI>
<tt><A href="random_access_iterator_tag.html">random_access_iterator_tag</A></tt>
</UL>
<UL>
<LI>
<tt><A href="iterator_traits.html">iterator_traits</A></tt>
</UL>
<h3>Functions</h3>
<UL>
<LI>
<tt><A href="iterator_category.html">iterator_category</A></tt>
<LI>
<tt><A href="value_type.html">value_type</A></tt>
<LI>
<tt><A href="distance_type.html">distance_type</A></tt>
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
 <A href="OutputIterator.html">Output Iterators</A> have neither a distance type nor a value
type; in many ways, in fact, <A href="OutputIterator.html">Output Iterators</A> aren't really
iterators.  Output iterators do not have a value type, because it is
impossible to obtain a value from an output iterator but only to write
a value through it.  They do not have a distance type, similarly,
because it is impossible to find the distance from one output iterator
to another.  Finding a distance requires a comparison for equality,
and output iterators do not support <tt>operator==</tt>.
<P><A name="2">[2]</A>
The <tt><A href="iterator_traits.html">iterator_traits</A></tt> class
relies on a C++ feature known as <i>partial specialization</i>.  Many of
today's compilers don't implement the complete standard; in
particular, many compilers do not support partial specialization.  If
your compiler does not support partial specialization, then you will
not be able to use <tt><A href="iterator_traits.html">iterator_traits</A></tt>, and you will have to 
continue to use the older iterator tag functions.
<P><A name="3">[3]</A>
Note that <A href="trivial.html">Trivial Iterator</A> does not appear in this list.
The <A href="trivial.html">Trivial Iterator</A> concept is introduced solely for conceptual
clarity; the STL does not actually define any <A href="trivial.html">Trivial Iterator</A>
types, so there is no need for a <A href="trivial.html">Trivial Iterator</A> tag.  There
is, in fact, a strong reason not to define one: the C++ type system
does not provide any way to distinguish between a pointer that is
being used as a trivial iterator (that is, a pointer to an object
that isn't part of an array) and a pointer that is being used as a
<A href="RandomAccessIterator.html">Random Access Iterator</A> into an array.
<h3>See also</h3>
<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="ForwardIterator.html">Forward Iterator</A>, 
<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, <A href="RandomAccessIterator.html">Random Access Iterator</A>,
<tt><A href="iterator_traits.html">iterator_traits</A></tt>, <A href="Iterators.html">Iterator Overview</A>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
