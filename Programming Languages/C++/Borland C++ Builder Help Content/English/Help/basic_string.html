<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>basic_string&lt;charT, traits, Alloc&gt;</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>basic_string&lt;charT, traits, Alloc&gt;</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "containers.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "type.gif" Alt=""   WIDTH = "194"  HEIGHT = "39" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
The <tt>basic_string</tt> class represents a <A href="Sequence.html">Sequence</A> of characters.  
It contains all the usual operations of a <A href="Sequence.html">Sequence</A>, and, additionally,
it contains standard string operations such as search and concatenation.
<P>
The <tt>basic_string</tt> class is parameterized by character type, and by
that type's <A href="character_traits.html">Character Traits</A>.  Most of the time, however, there is
no need to use the <tt>basic_string</tt> template directly.  The types
<tt>string</tt> and <tt>wstring</tt> are typedefs for, respectively,
<tt>basic_string&lt;char&gt;</tt> and <tt>basic_string&lt;wchar_t&gt;</tt>.
<P>
Some of <tt>basic_string</tt>'s member functions use an unusual method of
specifying positions and ranges.  In addition to the conventional
method using iterators, many of <tt>basic_string</tt>'s member functions use
a single value <tt>pos</tt> of type <tt>size_type</tt> to represent a position (in
which case the position is <tt>begin() + pos</tt>, and many of
<tt>basic_string</tt>'s member functions use two values, <tt>pos</tt> and <tt>n</tt>, to
represent a range.  In that case <tt>pos</tt> is the beginning of the range
and <tt>n</tt> is its size.  That is, the range is <tt>[begin() + pos, begin() +
pos + n)</tt>.
<P>
Note that the C++ standard does not specify the complexity of
<tt>basic_string</tt> operations.  In this implementation, <tt>basic_string</tt>
has performance characteristics very similar to those of <tt><A href="Vector.html">vector</A></tt>:
access to a single character is <i>O(1</i>), while copy and concatenation
are <i>O(N</i>).  By contrast, <tt><A href="Rope.html">rope</A></tt> has very different performance
characteristics: most <tt><A href="Rope.html">rope</A></tt> operations have logarithmic complexity.
<P>
Note also that, according to the C++ standard, <tt>basic_string</tt> has very
unusual iterator invalidation semantics.  Iterators may be invalidated
by <tt>swap</tt>, <tt>reserve</tt>, <tt>insert</tt>, and <tt>erase</tt> (and by functions that are
equivalent to <tt>insert</tt> and/or <tt>erase</tt>, such as <tt>clear</tt>, <tt>resize</tt>,
<tt>append</tt>, and <tt>replace</tt>).  Additionally, however, the first call to
<i>any</i> non-const member function, including the non-const version of
<tt>begin()</tt> or <tt>operator[]</tt>, may invalidate iterators.  (The intent of
these iterator invalidation rules is to give implementors greater
freedom in implementation techniques.)  In this implementation,
<tt>begin()</tt>, <tt>end()</tt>, <tt>rbegin()</tt>, <tt>rend()</tt>, <tt>operator[]</tt>, <tt>c_str()</tt>, and
<tt>data()</tt> do not invalidate iterators.  In this implementation,
iterators are only invalidated by member functions that explicitly
change the string's contents.
<h3>Example</h3>
<pre>
int main() { 
  string s(10u, ' ');           // Create a string of ten blanks.

  const char* A = &quot;this is a test&quot;;
  s += A;
  cout &lt;&lt; &quot;s = &quot; &lt;&lt; (s + '\n');
  cout &lt;&lt; &quot;As a null-terminated sequence: &quot; &lt;&lt; s.c_str() &lt;&lt; endl;
  cout &lt;&lt; &quot;The sixteenth character is &quot; &lt;&lt; s[15] &lt;&lt; endl;
  
  reverse(s.begin(), s.end());
  s.push_back('\n');
  cout &lt;&lt; s;
}
</pre>
<h3>Definition</h3>
Defined in the standard header <A href="string">string</A>.
<h3>Template parameters</h3>
<Table border>
<TR>
<TH>
Parameter
</TH>
<TH>
Description
</TH>
<TH>
Default
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>charT</tt>
</TD>
<TD VAlign=top>
The string's value type: the type of character it contains.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>traits</tt>
</TD>
<TD VAlign=top>
The <A href="character_traits.html">Character Traits</A> type, which encapsulates basic character
   operations.
</TD>
<TD VAlign=top>
<tt>char_traits&lt;charT&gt;</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>Alloc</tt>
</TD>
<TD VAlign=top>
The string's allocator, used for internal memory management.
</TD>
<TD VAlign=top>
<tt>alloc</tt>
</TD>
</tr>
</table>
<h3>Model of</h3>
<A href="RandomAccessContainer.html">Random Access Container</A>, 
<A href="Sequence.html">Sequence</A>.
<h3>Type requirements</h3>
In addition to the type requirements imposed by 
<A href="RandomAccessContainer.html">Random Access Container</A> and <A href="Sequence.html">Sequence</A>:
<UL>
<LI>
<tt>charT</tt> is a POD (&quot;plain ol' data&quot;) type.
<LI>
<tt>traits</tt> is a <A href="character_traits.html">Character Traits</A> type whose value type is
   <tt>charT</tt>
</UL>
<h3>Public base classes</h3>
None.
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The type of object, <tt>CharT</tt>, stored in the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>pointer</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Pointer to <tt>CharT</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reference</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Reference to <tt>CharT</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reference</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const reference to <tt>CharT</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
An unsigned integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>difference_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
A signed integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>static const size_type npos</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
The largest possible value of type <tt>size_type</tt>.  That is,
   <tt>size_type(-1)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate through a string.  A <tt>basic_string</tt> supplies
   <A href="RandomAccessIterator.html">Random Access Iterators</A>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate through a string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate backwards through a string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate backwards through a string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator begin()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the beginning of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator end()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the end of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator begin() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>const_iterator</tt> pointing to the beginning of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator end() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>const_iterator</tt> pointing to the end of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator rbegin()</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
   reversed string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator rend()</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the end of the
   reversed string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator rbegin() const</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>const_reverse_iterator</tt> pointing to the beginning of the
   reversed string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator rend() const</tt>
</TD>
<TD VAlign=top>
 <A href="ReversibleContainer.html">Reversible Container</A>
</TD>
<TD VAlign=top>
Returns a <tt>const_reverse_iterator</tt> pointing to the end of the
   reversed string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type size() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the size of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type length() const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Synonym for <tt>size()</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type max_size() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the largest possible size of the string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type capacity() const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>bool empty() const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
<tt>true</tt> if the string's size is <tt>0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reference operator[](size_type n)</tt>
</TD>
<TD VAlign=top>
 <A href="RandomAccessContainer.html">Random Access Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>n</tt>'th character.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reference operator[](size_type n) const</tt>
</TD>
<TD VAlign=top>
 <A href="RandomAccessContainer.html">Random Access Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>n</tt>'th character.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const charT* c_str() const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Returns a pointer to a null-terminated array of characters representing
   the string's contents.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const charT* data() const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Returns a pointer to an array of characters (not necessarily
   null-terminated) representing the string's contents.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Creates an empty string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string(const basic_string&amp; s, 
             size_type pos = 0, size_type n = npos)
</pre>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>, <tt>basic_string</tt>
</TD>
<TD VAlign=top>
Generalization of the copy constructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(const charT*)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Construct a string from a null-terminated character array.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Construct a string from a character array and a length.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Create a string with <tt>n</tt> copies of <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string(InputIterator first, InputIterator last)
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Create a string from a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>~basic_string()</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The destructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator=(const basic_string&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The assignment operator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator=(const charT* s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Assign a null-terminated character array to a string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator=(charT c)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Assign a single character to a string.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void reserve(size_t)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void swap(basic_string&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two strings.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
iterator insert(iterator pos,
                const T&amp; x)
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
void insert(iterator pos,
            InputIterator f, InputIterator l)
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Inserts the range <tt>[first, last)</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
void insert(iterator pos, 
            size_type n, const T&amp; x)
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Inserts <tt>n</tt> copies of <tt>x</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Inserts <tt>s</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; insert(size_type pos, 
                     const basic_string&amp; s, 
                     size_type pos1, size_type n)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Inserts a substring of <tt>s</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const charT* s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Inserts <tt>s</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Inserts the first n characters of <tt>s</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Inserts <tt>n</tt> copies of <tt>c</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append <tt>s</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; append(const basic_string&amp; s, 
                     size_type pos, size_type n)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append a substring of <tt>s</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const charT* s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append <tt>s</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append the first <tt>n</tt> characters of <tt>s</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append <tt>n</tt> copies of <tt>c</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string&amp; append(InputIterator first, InputIterator last)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append a range to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void push_back(charT c)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Append a single character to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>append(s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(const charT* s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>append(s)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(charT c)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>push_back(c)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator erase(iterator p)</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Erases the character at position <tt>p</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator erase(iterator first, iterator last)</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Erases the range <tt>[first, last)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; erase(size_type pos = 0, size_type n = npos)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Erases a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void clear()</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Erases the entire container.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void resize(size_type n, charT c = charT())</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Appends characters, or erases characters from the end, as necessary
   to make the string's length exactly <tt>n</tt> characters.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const basic_string&amp;)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Synonym for <tt>operator=</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre> 
basic_string&amp; assign(const basic_string&amp; s, 
                     size_type pos, size_type n)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Assigns a substring of <tt>s</tt> to <tt>*this</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Assigns the first <tt>n</tt> characters of <tt>s</tt> to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const charT* s)</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Assigns a null-terminated array of characters to <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Erases the existing characters and replaces them by <tt>n</tt> copies of <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string&amp; assign(InputIterator first, InputIterator last)
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Erases the existing characters and replaces them by <tt>[first, last)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const basic_string&amp; s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with the string <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const basic_string&amp; s, 
                      size_type pos1, size_type n1)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with a substring of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const charT* s, size_type n1)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with the first <tt>n1</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const charT* s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with a null-terminated character array.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      size_type n1, charT c)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with <tt>n1</tt> copies of <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const basic_string&amp; s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with the string <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const charT* s, size_type n)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with the first <tt>n</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const charT* s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with a null-terminated character array.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      size_type n, charT c)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with <tt>n</tt> copies of <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string&amp; replace(iterator first, iterator last, 
                      InputIterator f, InputIterator l)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Replaces a substring of <tt>*this</tt> with the range <tt>[f, l)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type copy(charT* buf, size_type n, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Copies a substring of <tt>*this</tt> to a buffer.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches for <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character <tt>pos</tt> of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches for the first <tt>n</tt> characters of <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character <tt>pos</tt> of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches for a null-terminated character array as a substring of <tt>*this</tt>, beginning at
   character <tt>pos</tt> of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches for the character <tt>c</tt>, beginning at character position <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward for <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character position <tt>min(pos, size())</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward for the first <tt>n</tt> characters of <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character position <tt>min(pos, size())</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward for a null-terminated character array as a substring of <tt>*this</tt>, beginning at
   character <tt>min(pos, size())</tt> 
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward for the character <tt>c</tt>, beginning at character position <tt>min(pos, size()</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to any character within the first <tt>n</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to any character within the first <tt>n</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is equal to any character within the first <tt>n</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is equal to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is not equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is not equal to any character within the first <tt>n</tt> characters of <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is not equal to any character within <tt>s</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Searches backward <tt>*this</tt>, beginning at <tt>min(pos, size())</tt>, for the first character
   that is not equal to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string substr(size_type pos = 0, size_type n = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Returns a substring of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(const basic_string&amp; s) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const basic_string&amp; s) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and a substring of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const basic_string&amp; s, size_type pos1, size_type n1) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of a substring of <tt>s</tt> and a substring of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(const charT* s) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const charT* s, size_type len = npos) const</tt>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of the first <tt>min(len, traits::length(s)</tt>
   characters of <tt>s</tt> and a substring of <tt>*this</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String concatenation.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const charT* s1,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String concatenation.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          const charT* s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String concatenation.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(charT c,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String concatenation.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          charT c)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String concatenation.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator==(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
String equality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator==(const charT* s1, 
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String equality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator==(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const charT* s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String equality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator!=(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
String inequality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator!=(const charT* s1, 
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String inequality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator!=(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const charT* s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String inequality.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator&lt;(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
               const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
String comparison.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator&lt;(const charT* s1, 
               const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String comparison.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator&lt;(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
               const charT* s2)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
String comparison.  A global function, not a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
void swap(basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two strings.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is,
           basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Reads <tt>s</tt> from the input stream <tt>is</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_istream&lt;charT, traits&gt;&amp; os,
           const basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Writes <tt>s</tt> to the output stream <tt>os</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
getline(basic_istream&lt;charT, traits&gt;&amp; is,
        basic_string&lt;charT, traits, Alloc&gt;&amp; s,
        charT delim)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Reads a string from the input stream <tt>is</tt>, stopping when it reaches <tt>delim</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
getline(basic_istream&lt;charT, traits&gt;&amp; is,
        basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
<tt>basic_string</tt>
</TD>
<TD VAlign=top>
Reads a single line from the input stream <tt>is</tt>
</TD>
</tr>
</table>
<h3>New members</h3>
These members are not defined in the 
<A href="RandomAccessContainer.html">Random Access Container</A> and <A href="Sequence.html">Sequence</A>:
requirements, but are specific to <tt>basic_string</tt>.
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>static const size_type npos</tt>
</TD>
<TD VAlign=top>
The largest possible value of type <tt>size_type</tt>.  That is,
   <tt>size_type(-1)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type length() const</tt>
</TD>
<TD VAlign=top>
Equivalent to  <tt>size()</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type capacity() const</tt>
</TD>
<TD VAlign=top>
Number of elements for which memory has been allocated.  That is,
   the size to which the string can grow before memory must be
   reallocated.  <tt>capacity()</tt> is always greater than or equal to 
   <tt>size()</tt>.   
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const charT* c_str() const</tt>
</TD>
<TD VAlign=top>
Returns a pointer to a null-terminated array of characters representing
   the string's contents.  For any string <tt>s</tt> it is guaranteed that
   the first <tt>s.size()</tt> characters in the array pointed to by <tt>s.c_str()</tt>
   are equal to the character in <tt>s</tt>, and that <tt>s.c_str()[s.size()]</tt> 
   is a null character.  Note, however, that it not necessarily the first 
   null character.  Characters within a string are permitted to be null.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const charT* data() const</tt>
</TD>
<TD VAlign=top>
Returns a pointer to an array of characters, not necessarily
   null-terminated, representing the string's contents.  <tt>data()</tt>
   is permitted, but not required, to be identical to <tt>c_str()</tt>.
   The first <tt>size()</tt> characters of that array are guaranteed to be identical
   to the characters in <tt>*this</tt>.  The return value of <tt>data()</tt> is never
   a null pointer, even if <tt>size()</tt> is zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(const basic_string&amp; s, size_type pos = 0, size_type n = npos)</tt>
</TD>
<TD VAlign=top>
Constructs a string from a substring of <tt>s</tt>.  The substring begins at
   character position <tt>pos</tt> and terminates at character position 
   <tt>pos + n</tt> or at the end of <tt>s</tt>, whichever comes first.  This constructor
   throws <tt>out_of_range</tt> if <tt>pos &gt; s.size()</tt>.  Note that when <tt>pos</tt> and <tt>n</tt>
   have their default values, this is just a copy constructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(const charT* s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>basic_string(s, s + traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>basic_string(s, s + n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator=(const charT* s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>operator=(basic_string(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator=(charT c)</tt>
</TD>
<TD VAlign=top>
Assigns to <tt>*this</tt> a string whose size is <tt>1</tt> and whose contents is
   the single character <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void reserve(size_t n)</tt>
</TD>
<TD VAlign=top>
Requests that the string's capacity be changed; the postcondition
   for this member function is that, after it is called, 
   <tt>capacity() &gt;= n</tt>.  You may request that a string decrease its
   capacity by calling <tt>reserve()</tt> with an argument less than the
   current capacity.  (If you call <tt>reserve()</tt> with an argument less 
   than the string's size, however, the capacity will only be reduced
   to <tt>size()</tt>.  A string's size can never be greater than its capacity.)
   <tt>reserve()</tt> throws <tt>length_error</tt> if <tt>n &gt; max_size()</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>insert(begin() + pos, s.begin(), s.end())</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; insert(size_type pos, 
                     const basic_string&amp; s, 
                     size_type pos1, size_type n)
</pre>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt> or <tt>pos1 &gt; s.size()</tt>, throws <tt>out_of_range</tt>.  Otherwise,
   equivalent to <tt>insert(begin() + pos, s.begin() + pos1, s.begin() + pos1 + min(n, s.size() - pos1))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const charT* s)</tt>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>insert(begin() + pos, s, s + traits::length(s))</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>insert(begin() + pos, s, s + n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; insert(size_type pos, size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>insert(begin() + pos, n, c)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), s.begin(), s.end())</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; append(const basic_string&amp; s, 
                     size_type pos, size_type n)
</pre>
</TD>
<TD VAlign=top>
If <tt>pos &gt; s.size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>insert(end(), s.begin() + pos, s.begin() + pos + min(n, s.size() - pos))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const charT* s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), s, s + traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), s, s + n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; append(size_type n, charT c)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), n, c)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string&amp; append(InputIterator first, InputIterator last)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), first, last)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void push_back(charT c)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(end(), c)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>append(s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(const charT* s)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>append(s)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; operator+=(charT c)</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>push_back(c)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; erase(size_type pos = 0, size_type n = npos)</tt>
</TD>
<TD VAlign=top>
If <tt>pos &gt; size()</tt>, throws <tt>out_of_range</tt>.  Otherwise, equivalent to
   <tt>erase(begin() + pos, begin() + pos + min(n, size() - pos))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const basic_string&amp; s)</tt>
</TD>
<TD VAlign=top>
Synonym for <tt>operator=</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; assign(const basic_string&amp; s, 
                     size_type pos, size_type n)
</pre>
</TD>
<TD VAlign=top>
Equivalent to (but probably faster than) <tt>clear()</tt> followed by <tt>insert(0, s, pos, n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const charT* s, size_type n)</tt>
</TD>
<TD VAlign=top>
Equivalent to (but probably faster than) <tt>clear()</tt> followed by <tt>insert(0, s, n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string&amp; assign(const charT* s)</tt>
</TD>
<TD VAlign=top>
Equivalent to (but probably faster than) <tt>clear()</tt> followed by <tt>insert(0, s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const basic_string&amp; s)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>erase(pos, n)</tt> followed by <tt>insert(pos, s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const basic_string&amp; s, size_type pos1, size_type n1)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>erase(pos, n)</tt> followed by <tt>insert(pos, s, pos1, n1)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const charT* s, size_type n1)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>erase(pos, n)</tt> followed by <tt>insert(pos, s, n1)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      const charT* s)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>erase(pos, n)</tt> followed by <tt>insert(pos, s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(size_type pos, size_type n, 
                      size_type n1, charT c)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>erase(pos, n)</tt> followed by <tt>insert(pos, n1, c)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const basic_string&amp; s)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(erase(first, last), s.begin(), s.end())</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const charT* s, size_type n)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(erase(first, last), s, s + n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      const charT* s)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(erase(first, last), s, s + traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
basic_string&amp; replace(iterator first, iterator last, 
                      size_type n, charT c)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(erase(first, last), n, c)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class InputIterator&gt;
basic_string&amp; replace(iterator first, iterator last, 
                      InputIterator f, InputIterator l)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>insert(erase(first, last), f, l)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type copy(charT* buf, size_type n, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Copies at most <tt>n</tt> characters from <tt>*this</tt> to a character array.
   Throws <tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.  Otherwise, equivalent to
   <tt><A href="copy.html">copy</A>(begin() + pos, begin() + pos + min(n, size()), buf)</tt>.
   Note that this member function does nothing other than copy 
   characters from <tt>*this</tt> to <tt>buf</tt>; in particular, it does not terminate
   <tt>buf</tt> with a null character.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Searches for <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character position <tt>pos</tt>.  It is almost the same as <tt><A href="search.html">search</A></tt>,
   except that <tt><A href="search.html">search</A></tt> tests elements for equality using 
   <tt>operator==</tt> or a user-provided function object, while this member
   function uses <tt>traits::eq</tt>.  Returns the lowest character position
   <tt>N</tt> such that <tt>pos &lt;= N</tt> and <tt>pos + s.size() &lt;= size()</tt> and such that, for every 
   <tt>i</tt> less than <tt>s.size()</tt>, <tt>(*this)[N + i]</tt> compares equal to <tt>s[i]</tt>.
   Returns <tt>npos</tt> if no such position <tt>N</tt> exists.  Note that it is legal
   to call this member function with arguments such that 
   <tt>s.size() &gt; size() - pos</tt>, but such a search will always fail.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches for the first <tt>n</tt> characters of <tt>s</tt> as a substring of <tt>*this</tt>, beginning at
   character <tt>pos</tt> of <tt>*this</tt>.  This is equivalent to
   <tt>find(basic_string(s, n), pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Searches for a null-terminated character array as a substring of <tt>*this</tt>, beginning at
   character <tt>pos</tt> of <tt>*this</tt>.  This is equivalent to 
   <tt>find(basic_string(s), pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Searches for the character <tt>c</tt>, beginning at character position <tt>pos</tt>.
   That is, returns the first character position <tt>N</tt> greater than or equal
   to <tt>pos</tt>, and less than <tt>size()</tt>, such that <tt>(*this)[N]</tt> compares equal 
   to <tt>c</tt>.  Returns <tt>npos</tt> if no such character position <tt>N</tt> exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward for <tt>s</tt> as a substring of <tt>*this</tt>.
   It is almost the same as <tt><A href="find_end.html">find_end</A></tt>,
   except that <tt><A href="find_end.html">find_end</A></tt> tests elements for equality using 
   <tt>operator==</tt> or a user-provided function object, while this member
   function uses <tt>traits::eq</tt>.  This member function returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N + s.size() &lt;= size()</tt>,
   and such that, for every <tt>i</tt> less than <tt>s.size()</tt>, <tt>(*this)[N + i]</tt>
   compares equal to <tt>s[i]</tt>.  
   Returns <tt>npos</tt> if no such position <tt>N</tt> exists.  Note that it is legal
   to call this member function with arguments such that 
   <tt>s.size() &gt; size()</tt>, but such a search will always fail.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches backward for the first <tt>n</tt> characters of <tt>s</tt> as a substring of <tt>*this</tt>.
   Equivalent to <tt>rfind(basic_string(s, n), pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward for a null-terminated character array as a substring of <tt>*this</tt>.
   Equivalent to <tt>rfind(basic_string(s), pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type rfind(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward for the character <tt>c</tt>.  That is, returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and
   such that <tt>(*this)[N]</tt> compares equal to <tt>c</tt>.  Returns <tt>npos</tt> if
   no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to any character within <tt>s</tt>.  This is similar to the
   standard algorithm <tt><A href="find_first_of.html">find_first_of</A></tt>, but differs because 
   <tt><A href="find_first_of.html">find_first_of</A></tt> compares characters using <tt>operator==</tt> or a 
   user-provided function object, while this member function uses
   <tt>traits::eq</tt>.  Returns the smallest character position <tt>N</tt> 
   such that <tt>pos &lt;= N &lt; size()</tt>, and such that <tt>(*this)[N]</tt>
   compares equal to some character within <tt>s</tt>.  
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is equal to any character within the range <tt>[s, s+n)</tt>.  That is,
   returns the smallest character position <tt>N</tt> 
   such that <tt>pos &lt;= N &lt; size()</tt>, and such that <tt>(*this)[N]</tt>
   compares equal to some character in <tt>[s, s+n)</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>find_first_of(s, pos, traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_of(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>find(c, pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const basic_string&amp; s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to any character within <tt>s</tt>.  
   Returns the smallest character position <tt>N</tt> 
   such that <tt>pos &lt;= N &lt; size()</tt>, and such that <tt>(*this)[N]</tt>
   does not compare equal to any character within <tt>s</tt>.  
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches within <tt>*this</tt>, beginning at <tt>pos</tt>, for the first character
   that is not equal to any character within the range <tt>[s, s+n)</tt>.  That is,
   returns the smallest character position <tt>N</tt> 
   such that <tt>pos &lt;= N &lt; size()</tt>, and such that <tt>(*this)[N]</tt>
   does not compare equal to any character in <tt>[s, s+n)</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(const charT* s, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>find_first_not_of(s, pos, traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_first_not_of(charT c, size_type pos = 0) const</tt>
</TD>
<TD VAlign=top>
Returns the smallest character position <tt>N</tt>
   such that <tt>pos &lt;= N &lt; size()</tt>, and such that <tt>(*this)[N]</tt>
   does not compare equal to <tt>c</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt> for the first character
   that is equal to any character within <tt>s</tt>.  That is, returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and such
   that <tt>(*this)[N]</tt> compares equal to some character within <tt>s</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt> for the first character
   that is equal to any character within the range <tt>[s, s+n)</tt>.
   That is, returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and such
   that <tt>(*this)[N]</tt> compares equal to some character within <tt>[s, s+n)</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>find_last_of(s, pos, traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_of(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>rfind(c, pos)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const basic_string&amp; s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt> for the first character
   that is not equal to any character within <tt>s</tt>.
   That is, returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and such
   that <tt>(*this)[N]</tt> does not compare equal to any character within <tt>s</tt>.
   Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const charT* s, size_type pos, size_type n) const</tt>
</TD>
<TD VAlign=top>
Searches backward within <tt>*this</tt> for the first character
   that is not equal to any character within <tt>[s, s+n)</tt>.
   That is, returns the largest
   character position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and such
   that <tt>(*this)[N]</tt> does not compare equal to any character within
   <tt>[s, s+n)</tt>.  Returns <tt>npos</tt> if no such character position exists.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(const charT* s, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>find_last_of(s, pos, traits::length(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type find_last_not_of(charT c, size_type pos = npos) const</tt>
</TD>
<TD VAlign=top>
Searches backward <tt>*this</tt> for the first character
   that is not equal to <tt>c</tt>.  That is, returns the largest character
   position <tt>N</tt> such that <tt>N &lt;= pos</tt> and <tt>N &lt; size()</tt>, and such 
   that <tt>(*this)[N]</tt> does not compare equal to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>basic_string substr(size_type pos = 0, size_type n = npos) const</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>basic_string(*this, pos, n)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(const basic_string&amp; s) const</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and <tt>*this</tt>, much like
   <tt>strcmp</tt>.  If <tt>traits::compare(data, s.data(), min(size(), s.size()))</tt>
   is nonzero, then it returns that nonzero value.  Otherwise returns a
   negative number if <tt>size() &lt; s.size()</tt>, a positive number if
   <tt>size() &gt; s.size()</tt>, and zero if the two are equal.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const basic_string&amp; s) const</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and a substring of <tt>*this</tt>.
   Equivalent to <tt>basic_string(*this, pos, n).compare(s)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const basic_string&amp; s, size_type pos1, size_type n1) const</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of a substring of <tt>s</tt> and a substring of <tt>*this</tt>.
   Equivalent to <tt>basic_string(*this, pos, n).compare(basic_string(s, pos1, n1))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(const charT* s) const</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of <tt>s</tt> and <tt>*this</tt>.
   Equivalent to <tt>compare(basic_string(s))</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>int compare(size_type pos, size_type n, const charT* s, size_type len = npos) const</tt>
</TD>
<TD VAlign=top>
Three-way lexicographical comparison of the first <tt>min(len, traits::length(s)</tt>
   characters of <tt>s</tt> and a substring of <tt>*this</tt>.
   Equivalent to <tt>basic_string(*this, pos, n).compare(basic_string(s, min(len, traits::length(s))))</tt>.   
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String concatenation.  Equivalent to creating a temporary copy
   of <tt>s</tt>, appending <tt>s2</tt>, and then returning the temporary copy.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const charT* s1,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String concatenation.
   Equivalent to creating a temporary <tt>basic_string</tt> object from <tt>s1</tt>,
   appending <tt>s2</tt>, and then returning the temporary object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          const charT* s2)
</pre>
</TD>
<TD VAlign=top>
String concatenation.  Equivalent to creating a temporary copy
   of <tt>s</tt>, appending <tt>s2</tt>, and then returning the temporary copy.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(charT c,
          const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String concatenation.  Equivalent to creating a temporary
   object with the constructor <tt>basic_string(1, c)</tt>, appending <tt>s2</tt>,
   and then returning the temporary object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_string&lt;charT, traits, Alloc&gt;
operator+(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
          charT c)
</pre>
</TD>
<TD VAlign=top>
String concatenation.  Equivalent to creating a temporary object,
   appending <tt>c</tt> with <tt>push_back</tt>, and then returning the temporary
   object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator==(const charT* s1, 
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String equality.  Equivalent to
   <tt>basic_string(s1).compare(s2) == 0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator==(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const charT* s2)
</pre>
</TD>
<TD VAlign=top>
String equality.  Equivalent to <tt>basic_string(s1).compare(s2) == 0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator!=(const charT* s1, 
                const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String inequality.  Equivalent to <tt>basic_string(s1).compare(s2) == 0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator!=(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
                const charT* s2)
</pre>
</TD>
<TD VAlign=top>
String inequality.  Equivalent to <tt>!(s1 == s2)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator&lt;(const charT* s1, 
               const basic_string&lt;charT, traits, Alloc&gt;&amp; s2)
</pre>
</TD>
<TD VAlign=top>
String comparison.  Equivalent to <tt>!(s1 == s2)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
bool operator&lt;(const basic_string&lt;charT, traits, Alloc&gt;&amp; s1,
               const charT* s2)
</pre>
</TD>
<TD VAlign=top>
String comparison.  Equivalent to <tt>!(s1 == s2)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is,
           basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
Reads <tt>s</tt> from the input stream <tt>is</tt>.  Specifically, it skips
   whitespace, and then replaces the contents of <tt>s</tt> with characters
   read from the input stream.  It continues reading characters until
   it encounters a whitespace character (in which case that character is
   not extracted), or until end-of-file, or, if <tt>is.width()</tt> is nonzero,
   until it has read <tt>is.width()</tt> characters.  This member function
   resets <tt>is.width()</tt> to zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is,
           const basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
Writes <tt>s</tt> to the output stream <tt>is</tt>.  It writes
   <tt>max(s.size(), is.width())</tt> characters, padding as necessary.
   This member function resets <tt>is.width()</tt> to zero.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
getline(basic_istream&lt;charT, traits&gt;&amp; is,
        basic_string&lt;charT, traits, Alloc&gt;&amp; s,
        charT delim)
</pre>
</TD>
<TD VAlign=top>
Replaces the contents of <tt>s</tt> with characters read from the input
   stream.  It continues reading characters until it encounters
   the character <tt>delim</tt> (in which case that character is extracted
   but not stored in <tt>s</tt>), or until end of file.  Note that <tt>getline</tt>,
   unlike <tt>operator&gt;&gt;</tt>, does not skip whitespace.  As the name suggests,
   it is most commonly used to read an entire line of text precisely as
   the line appears in an input file.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class charT, class traits, class Alloc&gt;
basic_istream&lt;charT, traits&gt;&amp;
getline(basic_istream&lt;charT, traits&gt;&amp; is,
        basic_string&lt;charT, traits, Alloc&gt;&amp; s)
</pre>
</TD>
<TD VAlign=top>
Equivalent to <tt>getline(is, s, is.widen('\n\))</tt>.
</TD>
</tr>
</table>
<h3>Notes</h3>
<h3>See also</h3>
<tt><A href="Rope.html">rope</A></tt>, <tt><A href="Vector.html">vector</A></tt>, <A href="character_traits.html">Character Traits</A>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
